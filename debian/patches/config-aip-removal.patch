Description: Guard AIP and VNIC code by config variables
 VNIC and AIP code in upstream is partially guarded by AIP and
 CONFIG_INFINIBAND_OPA_VNIC variables. This patch adds
 a CONFIG_INFINIBAND_OPA_AIP variable to enable AIP code and
 adds the ifdef blocks to remove AIP and VNIC code from the
 build.
Author: Brian T. Smith <bsmith@systemfabricworks.com>
Forwarded: not-needed
Last-Update: <2020-03-26>
---
This patch header follows DEP-3: http://dep.debian.net/deps/dep3/
--- a/hfi1/Makefile
+++ b/hfi1/Makefile
@@ -19,6 +19,9 @@
 	ipoib_main.o ipoib_tx.o rcva.o msix.o ipoib_rx.o netdev_rx.o
 hfi1-$(CONFIG_DEBUG_FS) += debugfs.o
 
+#ccflags-y += -DCONFIG_INFINIBAND_OPA_VNIC=1
+#ccflags-y += -DCONFIG_INFINIBAND_OPA_AIP=1
+
 CFLAGS_trace.o = -I$(src)
 ifdef MVERSION
 CFLAGS_driver.o = -DHFI_DRIVER_VERSION_BASE=\"$(MVERSION)\"
--- a/hfi1/chip.c
+++ b/hfi1/chip.c
@@ -8514,7 +8514,7 @@
 	__hfi1_rcd_eoi_intr(rcd);
 	local_irq_restore(flags);
 }
-
+#if defined(CONFIG_INFINIBAND_OPA_AIP) || defined(CONFIG_INFINIBAND_OPA_VNIC)
 /**
  * hfi1_netdev_rx_napi - napi poll function to move eoi inline
  * @napi - pointer to napi object
@@ -8559,6 +8559,7 @@
 
 	return IRQ_HANDLED;
 }
+#endif /* CONFIG_INFINIBAND_OPA_AIP || CONFIG_INFINIBAND_OPA_VNIC */
 
 /*
  * Receive packet IRQ handler.  This routine expects to be on its own IRQ.
@@ -14291,7 +14292,7 @@
 		add_rcvctrl(dd, RCV_CTRL_RCV_RSM_ENABLE_SMASK);
 	}
 }
-
+#if defined(CONFIG_INFINIBAND_OPA_AIP) || defined(CONFIG_INFINIBAND_OPA_VNIC)
 /*
  * Is a receive side mapping rule
  */
@@ -14300,6 +14301,7 @@
 {
 	return read_csr(dd, RCV_RSM_CFG + (8 * rule_index)) != 0;
 }
+#endif /* CONFIG_INFINIBAND_OPA_AIP || CONFIG_INFINIBAND_OPA_VNIC */
 
 /*
  * Add a receive side mapping rule.
@@ -14541,7 +14543,7 @@
 {
 	return (start + spare) > NUM_MAP_ENTRIES;
 }
-
+#if defined(CONFIG_INFINIBAND_OPA_AIP) || defined(CONFIG_INFINIBAND_OPA_VNIC)
 static bool hfi1_netdev_update_rmt(struct hfi1_devdata *dd)
 {
 	u8 i, j;
@@ -14604,7 +14606,9 @@
 	add_rsm_rule(dd, rule, rrd);
 	add_rcvctrl(dd, RCV_CTRL_RCV_RSM_ENABLE_SMASK);
 }
+#endif /* CONFIG_INFINIBAND_OPA_AIP || CONFIG_INFINIBAND_OPA_VNIC) */
 
+#ifdef CONFIG_INFINIBAND_OPA_AIP
 void hfi1_init_aip_rsm(struct hfi1_devdata *dd)
 {
 	/*
@@ -14636,7 +14640,8 @@
 		hfi1_enable_rsm_rule(dd, RSM_INS_AIP, &rrd);
 	}
 }
-
+#endif /* CONFIG_INFINIBAND_OPA_AIP */
+#ifdef CONFIG_INFINIBAND_OPA_VNIC
 /* Initialize RSM for VNIC */
 void hfi1_init_vnic_rsm(struct hfi1_devdata *dd)
 {
@@ -14667,13 +14672,15 @@
 {
 	clear_rsm_rule(dd, RSM_INS_VNIC);
 }
-
+#endif /* CONFIG_INFINIBAND_OPA_VNIC */
+#ifdef CONFIG_INFINIBAND_OPA_AIP
 void hfi1_deinit_aip_rsm(struct hfi1_devdata *dd)
 {
 	/* only actually clear the rule if it's the last user asking to do so */
 	if (atomic_fetch_add_unless(&dd->ipoib_rsm_usr_num, -1, 0) == 1)
 		clear_rsm_rule(dd, RSM_INS_AIP);
 }
+#endif /* CONFIG_INFINIBAND_OPA_AIP */
 
 static void init_rxe(struct hfi1_devdata *dd)
 {
@@ -14688,8 +14695,10 @@
 	init_qos(dd, rmt);
 	init_fecn_handling(dd, rmt);
 	complete_rsm_map_table(dd, rmt) /* Last if for netdev */;
+#if defined(CONFIG_INFINIBAND_OPA_AIP) || defined(CONFIG_INFINIBAND_OPA_VNIC)
 	/* record number of used rsm map entries for netdev*/
 	hfi1_netdev_set_free_rmt_idx(dd, rmt->used);
+#endif /* CONFIG_INFINIBAND_OPA_AIP || CONFIG_INFINIBAND_OPA_VNIC */
 	kfree(rmt);
 
 	/*
@@ -15254,9 +15263,11 @@
 		 (dd->revision >> CCE_REVISION_SW_SHIFT)
 		    & CCE_REVISION_SW_MASK);
 
+#if defined(CONFIG_INFINIBAND_OPA_AIP) || defined(CONFIG_INFINIBAND_OPA_VNIC)
 	/* alloc netdev data */
 	if (hfi1_netdev_alloc(dd))
 		goto bail_cleanup;
+#endif /* CONFIG_INFINIBAND_OPA_AIP || CONFIG_INFINIBAND_OPA_VNIC */
 	ret = set_up_context_variables(dd);
 	if (ret)
 		goto bail_cleanup;
@@ -15354,7 +15365,9 @@
 	hfi1_comp_vectors_clean_up(dd);
 	msix_clean_up_interrupts(dd);
 bail_cleanup:
+#if defined(CONFIG_INFINIBAND_OPA_AIP) || defined(CONFIG_INFINIBAND_OPA_VNUIC)
 	hfi1_netdev_free(dd);
+#endif /* CONFIG_INFINIBAND_OPA_AIP || CONFIG_INFINIBAND_OPA_VNIC */
 	hfi1_pcie_ddcleanup(dd);
 bail_free:
 	hfi1_free_devdata(dd);
--- a/hfi1/driver.c
+++ b/hfi1/driver.c
@@ -1688,7 +1688,7 @@
 	if (rhf_err_flags(packet->rhf))
 		show_eflags_errs(packet);
 }
-
+#ifdef CONFIG_INFINIBAND_OPA_AIP
 static void hfi1_ipoib_ib_rcv(struct hfi1_packet *packet)
 {
 	struct hfi1_ibport *ibp;
@@ -1721,9 +1721,7 @@
 
 	trace_input_ibhdr(rcd->dd, packet, !!(rhf_dc_info(packet->rhf)));
 
-#ifdef AIP
 	trace_ctxt_rsm_hist(rcd->ctxt);
-#endif
 
 	/* handle congesion notifications */
 	process_ecn(hfi1_ipoib_priv(netdev)->qp, packet);
@@ -1761,6 +1759,7 @@
 	ibp = rcd_to_iport(packet->rcd);
 	++ibp->rvp.n_pkt_drops;
 }
+#endif /* CONFIG_INFINIBAND_OPA_AIP */
 
 /*
  * The following functions are called by the interrupt handler. They are type
@@ -1964,15 +1963,18 @@
 	[RHF_RCV_TYPE_INVALID6] = process_receive_invalid,
 	[RHF_RCV_TYPE_INVALID7] = process_receive_invalid,
 };
-
+#if defined(CONFIG_INFINIBAND_OPA_AIP) || defined(CONFIG_INFINIBAND_OPA_VNIC)
 const rhf_rcv_function_ptr netdev_rhf_rcv_functions[] = {
 	[RHF_RCV_TYPE_EXPECTED] = process_receive_invalid,
 	[RHF_RCV_TYPE_EAGER] = process_receive_invalid,
+#ifdef CONFIG_INFINIBAND_OPA_AIP
 	[RHF_RCV_TYPE_IB] = hfi1_ipoib_ib_rcv,
+#endif
 	[RHF_RCV_TYPE_ERROR] = process_receive_error,
 	[RHF_RCV_TYPE_BYPASS] = hfi1_vnic_bypass_rcv,
 	[RHF_RCV_TYPE_INVALID5] = process_receive_invalid,
 	[RHF_RCV_TYPE_INVALID6] = process_receive_invalid,
 	[RHF_RCV_TYPE_INVALID7] = process_receive_invalid,
 };
+#endif /* CONFIG_INFINIBAND_OPA_AIP || CONFIG_INFINIBAND_OPA_VNIC */
 
--- a/hfi1/init.c
+++ b/hfi1/init.c
@@ -2000,8 +2000,11 @@
 	/* unregister from IB core */
 	hfi1_unregister_ib_device(dd);
 
+#if defined(CONFIG_INFINIBAND_OPA_AIP) || defined(CONFIG_INFINIBAND_OPA_VNIC)
 	/* free netdev data */
 	hfi1_netdev_free(dd);
+#endif /* CONFIG_INFINIBAND_OPA_AIP || CONFIG_INFINIBAND_OPA_VNIC */
+
 	/*
 	 * Disable the IB link, disable interrupts on the device,
 	 * clear dma engines, etc.
--- a/hfi1/ipoib.h
+++ b/hfi1/ipoib.h
@@ -67,7 +67,7 @@
 #include "netdev.h"
 
 #include <rdma/ib_verbs.h>
-
+#ifdef CONFIG_INFINIBAND_OPA_AIP
 #define HFI1_IPOIB_TXREQ_NAME_LEN   32
 
 #define HFI1_IPOIB_PSEUDO_LEN 20
@@ -216,5 +216,5 @@
 			     enum rdma_netdev_t type,
 			     struct rdma_netdev_alloc_params *params);
 #endif
-
+#endif /* CONFIG_INFINIBAND_OPA_AIP */
 #endif /* _IPOIB_H */
--- a/hfi1/ipoib_main.c
+++ b/hfi1/ipoib_main.c
@@ -55,15 +55,17 @@
 #include "hfi.h"
 #include "netdev.h"
 
-#ifdef AIP
+#ifdef CONFIG_INFINIBAND_OPA_AIP
 uint ipoib_accel = 1;
 module_param(ipoib_accel, uint, 0644);
-MODULE_PARM_DESC(ipoib_accel, "Accelerated ipoib mode");
 #else
 uint ipoib_accel = 0;
+module_param(ipoib_accel, uint, 0444);
 #endif
+MODULE_PARM_DESC(ipoib_accel, "Accelerated ipoib mode");
 EXPORT_SYMBOL(ipoib_accel);
 
+#ifdef CONFIG_INFINIBAND_OPA_AIP
 static u32 qpn_from_mac(u8 *mac_arr)
 {
 	return (u32)mac_arr[1] << 16 | mac_arr[2] << 8 | mac_arr[3];
@@ -441,4 +443,5 @@
 
 	return 0;
 }
+#endif /* CONFIG_INFINIBAND_OPA_AIP */
 #endif
--- a/hfi1/ipoib_rx.c
+++ b/hfi1/ipoib_rx.c
@@ -49,6 +49,7 @@
 #include "netdev.h"
 #include "ipoib.h"
 
+#if defined(CONFIG_INFINIBAND_OPA_AIP)
 #define HFI1_IPOIB_SKB_PAD NET_SKB_PAD + NET_IP_ALIGN
 
 static void copy_ipoib_buf(struct sk_buff *skb, void *data, int size)
@@ -135,3 +136,4 @@
 	hfi1_deinit_aip_rsm(dd);
 	hfi1_netdev_rx_destroy(dd);
 }
+#endif  /* CONFIG_INFINIBAND_OPA_AIP */
--- a/hfi1/ipoib_tx.c
+++ b/hfi1/ipoib_tx.c
@@ -58,6 +58,7 @@
 #include "trace_ibhdrs.h"
 #include "ipoib.h"
 
+#ifdef CONFIG_INFINIBAND_OPA_AIP
 /* Add a convenience helper */
 #define CIRC_ADD(val, add, size) (((val) + (add)) & ((size) - 1))
 #define CIRC_NEXT(val, size) CIRC_ADD(val, 1, size)
@@ -879,3 +880,4 @@
 		(void)hfi1_ipoib_drain_tx_ring(txq, txq->tx_ring.max_items);
 	}
 }
+#endif /* CONFIG_INFINIBAND_OPA_AIP */
--- a/hfi1/msix.c
+++ b/hfi1/msix.c
@@ -204,7 +204,7 @@
 	return msix_request_rcd_irq_common(rcd, receive_context_interrupt,
 					   receive_context_thread, name);
 }
-
+#if defined(CONFIG_INFINIBAND_OPA_AIP) || defined(CONFIG_INFINIBAND_OPA_VNIC)
 /**
  * msix_request_rcd_irq() - Helper function for RCVAVAIL IRQs
  * for netdev context
@@ -219,6 +219,7 @@
 	return msix_request_rcd_irq_common(rcd, receive_context_interrupt_napi,
 					   NULL, name);
 }
+#endif /* CONFIG_INFINIBAND_OPA_AIP || CONFIG_INFINIBAND_OPA_VNIC */
 
 /**
  * msix_request_smda_ira() - Helper for getting SDMA IRQ resources
@@ -371,6 +372,7 @@
 	pci_free_irq_vectors(dd->pcidev);
 }
 
+#if defined(CONFIG_INFINIBAND_OPA_AIP) || defined(CONFIG_INFINIBAND_OPA_VNIC)
 /**
  * msix_netdev_syncrhonize_irq() - Vnic IRQ synchronize
  * @dd: valid devdata
@@ -389,3 +391,4 @@
 		synchronize_irq(me->irq);
 	}
 }
+#endif /* CONFIG_INFINIBAND_OPA_AIP || CONFIG_INFINIBAND_OPA_VNIC */
--- a/hfi1/netdev.h
+++ b/hfi1/netdev.h
@@ -54,6 +54,7 @@
 #include <linux/netdevice.h>
 #include <linux/idr.h>
 
+#if defined(CONFIG_INFINIBAND_OPA_AIP) || defined(CONFIG_INFINIBAND_OPA_VNIC)
 /**
  * struct hfi1_netdev_rxq - Receive Queue for HFI
  * dummy netdev. Both IPoIB and VNIC netdevices will be working on
@@ -69,12 +70,14 @@
 };
 
 #define HFI1_NETDEV_MAX 255
+#endif /* CONFIG_INFINIBAND_OPA_AIP || CONFIG_INFINIBAND_OPA_VNIC */
 /*
  * Number of VNIC contexts used. Ensure it is less than or equal to
  * max queues supported by VNIC (HFI1_VNIC_MAX_QUEUE).
  */
 #define HFI1_NUM_NETDEV_CTXT   8
 
+#if defined(CONFIG_INFINIBAND_OPA_AIP) || defined(CONFIG_INFINIBAND_OPA_VNIC)
 /* Number of VNIC RSM entries */
 #define NUM_NETDEV_MAP_ENTRIES 8
 
@@ -229,5 +232,6 @@
  * @budget: budget
  */
 int hfi1_netdev_rx_napi(struct napi_struct *napi, int budget);
+#endif /* CONFIG_INFINIBAND_OPA_AIP || CONFIG_INFINIBAND_OPA_VNIC */
 
 #endif /* HFI1_NETDEV_H */
--- a/hfi1/netdev_rx.c
+++ b/hfi1/netdev_rx.c
@@ -61,6 +61,8 @@
 #include <linux/etherdevice.h>
 #include <rdma/ib_verbs.h>
 
+#if defined(CONFIG_INFINIBAND_OPA_AIP) || defined(CONFIG_INFINIBAND_OPA_VNIC)
+
 static int hfi1_netdev_setup_ctxt(struct hfi1_netdev_priv *priv,
 				  struct hfi1_ctxtdata *uctxt)
 {
@@ -438,3 +440,5 @@
 
 	return idr_get_next(&priv->idr, start_id);
 }
+
+#endif /* CONFIG_INFINIBAND_OPA_AIP || CONFIG_INFINIBAND_OPA_VNIC */
--- a/hfi1/rcva.c
+++ b/hfi1/rcva.c
@@ -52,6 +52,7 @@
 #include "rcva.h"
 #include "hfi.h"
 
+#if defined(CONFIG_INFINIBAND_OPA_AIP) || defined(CONFIG_INFINIBAND_OPA_VNIC)
 #define GROUP_SIZE RCV_INCREMENT
 #define MAX_BUFFER_SIZE (256 * 1024)
 #define MAX_PER_CONTEXT (2048 / GROUP_SIZE)
@@ -370,3 +371,4 @@
 		gen_pool_free(r->te_pool, s->base + 1, s->size);
 	s->size = 0;
 }
+#endif /* CONFIG_INFINIBAND_OPA_AIP || CONFIG_INFINIBAND_OPA_VNIC */
--- a/hfi1/trace.c
+++ b/hfi1/trace.c
@@ -529,7 +529,7 @@
 	.count = ATOMIC_INIT(0)
 };
 
-#ifdef AIP
+#if defined(CONFIG_INFINIBAND_OPA_AIP) || defined(CONFIG_INFINIBAND_OPA_VNIC)
 const char *hfi1_trace_print_rsm_hist(struct trace_seq *p, unsigned int ctxt)
 {
 	int i, len = ARRAY_SIZE(hist.data);
@@ -559,7 +559,7 @@
 	trace_seq_putc(p, 0);
 	return ret;
 }
-#endif
+#endif /* CONFIG_INFINIBAND_OPA_AIP || CONFIG_INFINIBAND_OPA_VNIC */
 
 __hfi1_trace_fn(AFFINITY);
 __hfi1_trace_fn(PKT);
--- a/hfi1/trace_ctxts.h
+++ b/hfi1/trace_ctxts.h
@@ -138,7 +138,7 @@
 		      )
 );
 
-#ifdef AIP
+#if defined(CONFIG_INFINIBAND_OPA_AIP) || defined(CONFIG_INFINIBAND_OPA_VNIC)
 const char *hfi1_trace_print_rsm_hist(struct trace_seq *p, unsigned int ctxt);
 TRACE_EVENT(ctxt_rsm_hist,
 	    TP_PROTO(unsigned int ctxt),
@@ -147,7 +147,7 @@
 	    TP_fast_assign(__entry->ctxt = ctxt;),
 	    TP_printk("%s", hfi1_trace_print_rsm_hist(p, __entry->ctxt))
 );
-#endif
+#endif /* CONFIG_INFINIBAND_OPA_AIP || CONFIG_INFINIBAND_OPA_VNIC */
 
 #endif /* __HFI1_TRACE_CTXTS_H */
 
--- a/hfi1/verbs.c
+++ b/hfi1/verbs.c
@@ -1884,7 +1884,7 @@
 					 setup);
 		break;
 #endif
-
+#ifdef CONFIG_INFINIBAND_OPA_AIP
 	case RDMA_NETDEV_IPOIB:
 		dev = hfi1_ipoib_alloc_rn(device,
 					  port_num,
@@ -1893,7 +1893,7 @@
 					  name_assign_type,
 					  setup);
 		break;
-
+#endif
 	default:
 		dev = ERR_PTR(-EOPNOTSUPP);
 		break;
