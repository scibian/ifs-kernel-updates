Description: Port rdmavt to kernel 4.9.0
Author: Brian T. Smith <bsmith@systemfabricworks.com>
Forwarded: not-needed
Last-Update: <2020-05-21>
---
This patch header follows DEP-3: http://dep.debian.net/deps/dep3/
--- a/Makefile
+++ b/Makefile
@@ -8,7 +8,7 @@
 #kbuild part of makefile
 
 CFLAGS_MODULE += -DUSE_PI_LED_ENABLE=1 -DIFS_DEB9
-obj-y :=
+obj-y := rdmavt/
 
 else
 #normal makefile
--- a/compat/compat.h
+++ b/compat/compat.h
@@ -44,46 +44,51 @@
  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  *
  */
-#if !defined(RH77_COMPAT_H)
-#define RH77_COMPAT_H
+#if !defined(DEB9_COMPAT_H)
+#define DEB9_COMPAT_H
 
-#define HAVE_IB_GID_ATTR
-#define POST_HAS_CONST
-#define CREATE_FLOW_HAS_UDATA
-#define CREATE_AH_HAS_UDATA
-#define HAVE_ALLOC_RDMA_NETDEV
-#define HAVE_RDMA_NETDEV_GET_PARAMS
-#define HAVE_NET_DEVICE_EXTENDED
-#define HAVE_ARRAY_SIZE
+#undef HAVE_IB_GID_ATTR
+#undef POST_HAS_CONST
+#undef CREATE_FLOW_HAS_UDATA
+#undef CREATE_AH_HAS_UDATA
+#undef HAVE_ALLOC_RDMA_NETDEV
+#undef HAVE_RDMA_NETDEV_GET_PARAMS
+#undef HAVE_NET_DEVICE_EXTENDED
+#undef HAVE_ARRAY_SIZE
 #define HAVE_NOSPEC_H
 #define VM_OPS_FAULT_HAVE_VMA
-#define HAVE_MAX_SEND_SGE
-#define HAVE_KMALLOC_ARRAY_NODE
-#define HAVE_IBDEV_DRIVER_ID
-#define HAVE_IB_GET_CACHED_SUBNET_PREFIX
+#undef HAVE_MAX_SEND_SGE
+#undef HAVE_KMALLOC_ARRAY_NODE
+#undef HAVE_IBDEV_DRIVER_ID
+#undef HAVE_IB_GET_CACHED_SUBNET_PREFIX
 #define HAVE_SECURITY_H
 #define HAVE_AIO_WRITE
-#define HAVE_DEVICE_RH
-#define NEED_KTHREAD_HELPER_FUNCTIONS
-#define NEED_CURRENT_TIME
+#undef HAVE_DEVICE_RH
+#undef NEED_KTHREAD_HELPER_FUNCTIONS
+#undef NEED_CURRENT_TIME
 #define HAVE_RDMA_SET_DEVICE_SYSFS_GROUP
 #define NEED_POLL_T
-#define HAVE_RDMA_COPY_AH_ATTR
+#undef HAVE_RDMA_COPY_AH_ATTR
 #define NEED_FILE_FINISH
 #define NEED_PCI_BRIDGE_SECONDARY_BUS_RESET
 #define HAS_PORT_IMMUTABLE
+#define NEED_IB_HELPER_FUNCTIONS
+#define NEED_RVT_DMA_MAPPINGS
+#define IB_MODIFY_QP_IS_OK_HAS_LINK
+#define GET_DEV_FW_STR_HAS_LEN
+#define NEED_MSIX_ENTRY
+#undef HAVE_IB_QP_CREATE_USE_GFP_NOIO /* causes qp create from IPoIB to fail */
+#define NO_RDMA_AH_ATTR_TYPE
 
 #include "compat_common.h"
 
-#define __GFP_RECLAIM	(__GFP_WAIT)
-
 #define IB_FW_VERSION_NAME_MAX			  ETHTOOL_FWVERS_LEN
-#define OPA_CLASS_PORT_INFO_PR_SUPPORT BIT(26)
 
-#define NET_NAME_UNKNOWN 0
+struct ib_ah *rdma_create_ah(struct ib_pd *pd, struct rdma_ah_attr *ah_attr);
+int rdma_destroy_ah(struct ib_ah *ah);
 
 #define ib_register_device(a, b)  \
-	ib_register_device((a), (b), (rdi->driver_f.port_callback))
+	ib_register_device((a), (rdi->driver_f.port_callback))
 #define alloc_netdev_mqs(size, name, name_assign_type, setup, sdma, ctxts) \
 	alloc_netdev_mqs((size), (name), (setup), (sdma), (ctxts))
 
@@ -94,52 +99,6 @@
 	(likely(__range_not_ok(addr, size, user_addr_max()) == 0))
 #define _ib_alloc_device ib_alloc_device
 
-struct hfi1_msix_entry;
-struct hfi1_devdata;
-
 void pcie_flr(struct pci_dev *dev);
 
-int bitmap_print_to_pagebuf(bool list, char *buf,
-			    const unsigned long *maskp, int nmaskbits);
-int debugfs_use_file_start(struct dentry *dentry, int *srcu_idx)
-__acquires(&debugfs_srcu);
-
-void debugfs_use_file_finish(int srcu_idx) __releases(&debugfs_srcu);
-struct ib_umem *ib_umem_get_hfi(struct ib_ucontext *context, unsigned long addr,
-				size_t size, int access, int dmasync);
-
-static inline long compat_get_user_pages(unsigned long start,
-					 unsigned long nr_pages,
-					 unsigned int gup_flags,
-					 struct page **pages,
-					 struct vm_area_struct **vmas)
-{
-	return get_user_pages(current, current->mm, start,
-			      nr_pages, 1, 1, pages, vmas);
-}
-
-#define get_user_pages(start, nr_pages, gup_flags, pages, vmas) \
-	compat_get_user_pages(start, nr_pages, gup_flags, pages, vmas)
-
-static inline int simple_positive(struct dentry *dentry)
-{
-	return !d_unhashed(dentry) && dentry->d_inode;
-}
-
-static inline void hfi1_enable_intx(struct pci_dev *pdev)
-{
-	/* first, turn on INTx */
-	pci_intx(pdev, 1);
-	/* then turn off MSI-X */
-	pci_disable_msix(pdev);
-}
-
-/* Helpers to hide struct msi_desc implementation details */
-#define msi_desc_to_dev(desc)           ((desc)->dev)
-#define dev_to_msi_list(dev)            (&(dev)->msi_list)
-#define first_msi_entry(dev)            \
-	list_first_entry(dev_to_msi_list((dev)), struct msi_desc, list)
-#define for_each_msi_entry(desc, dev)   \
-	list_for_each_entry((desc), dev_to_msi_list((dev)), list)
-
-#endif //RH77_COMPAT
+#endif //DEB9_COMPAT
--- a/rdmavt/compat.c
+++ b/rdmavt/compat.c
@@ -58,49 +58,221 @@
 #include "../hfi1/hfi.h"
 #include "compat.h"
 
-/**
- * debugfs_use_file_start - mark the beginning of file data access
- * @dentry: the dentry object whose data is being accessed.
- * @srcu_idx: a pointer to some memory to store a SRCU index in.
- *
- * Up to a matching call to debugfs_use_file_finish(), any
- * successive call into the file removing functions debugfs_remove()
- * and debugfs_remove_recursive() will block. Since associated private
- * file data may only get freed after a successful return of any of
- * the removal functions, you may safely access it after a successful
- * call to debugfs_use_file_start() without worrying about
- * lifetime issues.
- *
- * If -%EIO is returned, the file has already been removed and thus,
- * it is not safe to access any of its data. If, on the other hand,
- * it is allowed to access the file data, zero is returned.
+
+#undef rdma_create_ah
+#undef rdma_destroy_ah
+
+struct ib_ah *rdma_create_ah(struct ib_pd *pd, struct rdma_ah_attr *ah_attr)
+{
+	struct ib_ah *ah;
+	ah = pd->device->create_ah(pd, ah_attr);
+	if (!IS_ERR(ah)) {
+		ah->device  = pd->device;
+		ah->pd      = pd;
+		ah->uobject = NULL;
+		atomic_inc(&pd->usecnt);
+	}
+	return ah;
+}
+EXPORT_SYMBOL(rdma_create_ah);
+
+//DMA
+/*
+ * The following functions implement driver specific replacements
+ * for the ib_dma_*() functions.
  *
- * Regardless of the return code, any call to
- * debugfs_use_file_start() must be followed by a matching call
- * to debugfs_use_file_finish().
+ * These functions return kernel virtual addresses instead of
+ * device bus addresses since the driver uses the CPU to copy
+ * data instead of using hardware DMA.
  */
-int debugfs_use_file_start(struct dentry *dentry, int *srcu_idx)
-	__acquires(&debugfs_srcu)
+static int rvt_mapping_error(struct ib_device *dev, u64 dma_addr)
 {
-	*srcu_idx = srcu_read_lock(&debugfs_srcu);
-	barrier();
-	if (d_unlinked(dentry))
-		return -EIO;
-	return 0;
+	return dma_addr == BAD_DMA_ADDRESS;
+}
+
+static u64 rvt_dma_map_single(struct ib_device *dev, void *cpu_addr,
+                              size_t size, enum dma_data_direction direction)
+{
+	if (WARN_ON(!valid_dma_direction(direction)))
+		return BAD_DMA_ADDRESS;
+	return (u64)cpu_addr;
+}
+
+static void rvt_dma_unmap_single(struct ib_device *dev, u64 addr, size_t size,
+                                 enum dma_data_direction direction)
+{
+	/* This is a stub, nothing to be done here */
+}
+
+static u64 rvt_dma_map_page(struct ib_device *dev, struct page *page,
+                            unsigned long offset, size_t size,
+                            enum dma_data_direction direction)
+{        u64 addr;
+
+	if (WARN_ON(!valid_dma_direction(direction)))
+		return BAD_DMA_ADDRESS;
+
+	addr = (u64)page_address(page);
+	if (addr)
+		addr += offset;
+
+	return addr;
+}
+
+static void rvt_dma_unmap_page(struct ib_device *dev, u64 addr, size_t size,
+                               enum dma_data_direction direction)
+{
+	/* This is a stub, nothing to be done here */
+}
+
+static int rvt_map_sg(struct ib_device *dev, struct scatterlist *sgl,
+                      int nents, enum dma_data_direction direction)
+{
+	struct scatterlist *sg;
+	u64 addr;
+	int i;        int ret = nents;
+
+	if (WARN_ON(!valid_dma_direction(direction)))
+		return 0;
+
+	for_each_sg(sgl, sg, nents, i) {
+		addr = (u64)page_address(sg_page(sg));
+		if (!addr) {
+			ret = 0;
+			break;
+		}
+		sg->dma_address = addr + sg->offset;
+#ifdef CONFIG_NEED_SG_DMA_LENGTH
+		sg->dma_length = sg->length;
+#endif
+	}
+	return ret;
+}
+
+static void rvt_unmap_sg(struct ib_device *dev,
+                         struct scatterlist *sg, int nents,
+                         enum dma_data_direction direction)
+{
+	/* This is a stub, nothing to be done here */
+}
+
+static int rvt_map_sg_attrs(struct ib_device *dev, struct scatterlist *sgl,
+                            int nents, enum dma_data_direction direction,
+                            unsigned long attrs)
+{
+	return rvt_map_sg(dev, sgl, nents, direction);
+}
+
+static void rvt_unmap_sg_attrs(struct ib_device *dev,
+                               struct scatterlist *sg, int nents,
+                               enum dma_data_direction direction,
+                               unsigned long attrs)
+{
+	return rvt_unmap_sg(dev, sg, nents, direction);
+}
+
+static void rvt_sync_single_for_cpu(struct ib_device *dev, u64 addr,
+                                    size_t size, enum dma_data_direction dir)
+{
+}
+
+static void rvt_sync_single_for_device(struct ib_device *dev, u64 addr,
+                                       size_t size,
+                                       enum dma_data_direction dir)
+{
+}
+
+static void *rvt_dma_alloc_coherent(struct ib_device *dev, size_t size,
+                                    u64 *dma_handle, gfp_t flag)
+{
+	struct page *p;
+	void *addr = NULL;
+
+	p = alloc_pages(flag, get_order(size));
+	if (p)
+		addr = page_address(p);
+	if (dma_handle)
+		*dma_handle = (u64)addr;
+	return addr;
+}
+
+static void rvt_dma_free_coherent(struct ib_device *dev, size_t size,
+                                  void *cpu_addr, u64 dma_handle)
+{
+	free_pages((unsigned long)cpu_addr, get_order(size));
+}
+
+/*
+ * We should only need to wait 100ms after FLR, but some devices take longer.
+ * Wait for up to 1000ms for config space to return something other than -1.
+ * Intel IGD requires this when an LCD panel is attached.  We read the 2nd
+ * dword because VFs don't implement the 1st dword.
+ */
+static void pci_flr_wait(struct pci_dev *dev)
+{
+	int i = 0;
+	u32 id;
+
+	do {
+		msleep(100);
+		pci_read_config_dword(dev, PCI_COMMAND, &id);
+	} while (i++ < 10 && id == ~0);
+
+	if (id == ~0)
+		dev_warn(&dev->dev, "Failed to return from FLR\n");
+	else if (i > 1)
+		dev_info(&dev->dev, "Required additional %dms to return from FLR\n",
+				 (i - 1) * 100);
 }
-EXPORT_SYMBOL(debugfs_use_file_start);
 
 /**
- * debugfs_use_file_finish - mark the end of file data access
- * @srcu_idx: the SRCU index "created" by a former call to
- *            debugfs_use_file_start().
+ * pcie_flr - initiate a PCIe function level reset
+ *  @dev:        device to reset
  *
- * Allow any ongoing concurrent call into debugfs_remove() or
- * debugfs_remove_recursive() blocked by a former call to
- * debugfs_use_file_start() to proceed and return to its caller.
+ * Initiate a function level reset on @dev.  The caller should ensure the
+ * device supports FLR before calling this function, e.g. by using the
+ * pcie_has_flr() helper.
  */
-void debugfs_use_file_finish(int srcu_idx) __releases(&debugfs_srcu)
+void pcie_flr(struct pci_dev *dev)
 {
-	srcu_read_unlock(&debugfs_srcu, srcu_idx);
+	if (!pci_wait_for_pending_transaction(dev)) {
+		dev_err(&dev->dev,
+				"timed out waiting for pending transaction; performing function level reset anyway\n");
+	}
+	pcie_capability_set_word(dev,
+							 PCI_EXP_DEVCTL,
+							 PCI_EXP_DEVCTL_BCR_FLR);
+	pci_flr_wait(dev);
 }
-EXPORT_SYMBOL(debugfs_use_file_finish);
+EXPORT_SYMBOL_GPL(pcie_flr);
+
+int rdma_destroy_ah(struct ib_ah *ah)
+{
+	struct ib_pd *pd;
+	int ret;
+
+	pd = ah->pd;
+	ret = ah->device->destroy_ah(ah);
+	if (!ret) {
+		atomic_dec(&pd->usecnt);
+	}
+
+	return ret;
+}
+EXPORT_SYMBOL(rdma_destroy_ah);
+
+struct ib_dma_mapping_ops rvt_default_dma_mapping_ops = {
+	.mapping_error = rvt_mapping_error,
+	.map_single = rvt_dma_map_single,
+	.unmap_single = rvt_dma_unmap_single,
+	.map_page = rvt_dma_map_page,
+	.unmap_page = rvt_dma_unmap_page,
+	.map_sg = rvt_map_sg,
+	.unmap_sg = rvt_unmap_sg,
+	.map_sg_attrs = rvt_map_sg_attrs,
+	.unmap_sg_attrs = rvt_unmap_sg_attrs,
+	.sync_single_for_cpu = rvt_sync_single_for_cpu,
+	.sync_single_for_device = rvt_sync_single_for_device,
+	.alloc_coherent = rvt_dma_alloc_coherent,
+	.free_coherent = rvt_dma_free_coherent
+};
--- a/rdmavt/Makefile
+++ b/rdmavt/Makefile
@@ -8,7 +8,7 @@
 ifneq ($(KERNELRELEASE),)
 #kbuild part of makefile
 
-NOSTDINC_FLAGS += -I${M}/include -I${M}/compat
+NOSTDINC_FLAGS += -I${M}/include -I${M}/include/uapi -I${M}/compat
 
 obj-$(CONFIG_INFINIBAND_RDMAVT) += rdmavt.o
 
--- a/include/uapi/rdma/rdma_user_ioctl.h
+++ b/include/uapi/rdma/rdma_user_ioctl.h
@@ -38,9 +38,10 @@
 #include <rdma/hfi/hfi1_ioctl.h>
 #include <rdma/rdma_user_ioctl_cmds.h>
 
+#ifndef IB_IOCTL_MAGIC
 /* Legacy name, for user space application which already use it */
 #define IB_IOCTL_MAGIC		RDMA_IOCTL_MAGIC
-
+#endif
 /*
  * General blocks assignments
  * It is closed on purpose do not expose it it user space
@@ -49,10 +50,18 @@
  */
 
 /* MAD specific section */
+#ifndef IB_USER_MAD_REGISTER_AGENT
 #define IB_USER_MAD_REGISTER_AGENT	_IOWR(RDMA_IOCTL_MAGIC, 0x01, struct ib_user_mad_reg_req)
+#endif
+#ifndef IB_USER_MAD_UNREGISTER_AGENT
 #define IB_USER_MAD_UNREGISTER_AGENT	_IOW(RDMA_IOCTL_MAGIC,  0x02, __u32)
+#endif
+#ifndef IB_USER_MAD_ENABLE_PKEY
 #define IB_USER_MAD_ENABLE_PKEY		_IO(RDMA_IOCTL_MAGIC,   0x03)
+#endif
+#ifndef IB_USER_MAD_REGISTER_AGENT2
 #define IB_USER_MAD_REGISTER_AGENT2	_IOWR(RDMA_IOCTL_MAGIC, 0x04, struct ib_user_mad_reg_req2)
+#endif
 
 /* HFI specific section */
 /* allocate HFI and context */
--- a/hfi1/hfi.h
+++ b/hfi1/hfi.h
@@ -2625,6 +2625,7 @@
 
 static inline void hfi1_make_opa_lid(struct rdma_ah_attr *attr)
 {
+#ifndef NO_RDMA_AH_ATTR_TYPE
 	const struct ib_global_route *grh = rdma_ah_read_grh(attr);
 	u32 dlid = rdma_ah_get_dlid(attr);
 
@@ -2647,6 +2648,7 @@
 		dlid = be32_to_cpu(OPA_LID_PERMISSIVE);
 
 	rdma_ah_set_dlid(attr, dlid);
+#endif /* NO_RDMA_AH_ATTR_TYPE */
 }
 
 static inline u8 hfi1_get_packet_type(u32 lid)
--- a/include/rdma/rdmavt_qp.h
+++ b/include/rdma/rdmavt_qp.h
@@ -48,6 +48,7 @@
  *
  */
 
+#include <linux/vmalloc.h>
 #include <rdma/rdma_vt.h>
 #include <rdma/ib_pack.h>
 #include <rdma/ib_verbs.h>
